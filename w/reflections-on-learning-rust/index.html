<!doctype html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"/><title>hyperbo.la :: Reflections on Learning Rust By Building Punchtop</title><meta property="og:site_name" content="hyperbo.la"/><meta property="og:url" content="https://hyperbo.la/w/reflections-on-learning-rust/"/><meta property="og:image" content="https://hyperbo.la/logo.png"/><meta property="og:type" content="article"/><meta property="og:article:published_time" content="2019-01-27T00:00:00.000+00:00"/><meta property="og:article:modified_time" content="2019-01-27T00:00:00.000+00:00"/><meta property="og:article:author" content="https://www.facebook.com/ryan.lopopolo"/><meta property="og:title" content="Reflections on Learning Rust By Building Punchtop"/><meta property="og:description" content="To learn Rust, I implemented an audio game. There were some things I liked and some things I didn&#39;t. Some things were easy and some were hard. And there were plenty of libraries that were a joy to use."/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><meta name="msapplication-TileColor" content="#222222"/><meta name="theme-color" content="#222222"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-30651847-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-30651847-1")</script><link href="/main.19b590735999f5635f25.css" rel="stylesheet"></head><body class="blog"><div class="container mb-5"><nav class="navbar navbar-expand-md"><a class="navbar-brand p-0" href="/" aria-label="hyperbola"><img class="float-left" title="hyperbola" alt="Hyperbola logo" src="/ea3a0c4f0b6d4c1600f0444f02ac44d9.svg"/> <span class="sr-only">hyperbola</span> </a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto"><div class="container d-flex flex-column flex-md-row justify-content-end"><li class="nav-item"><a class="nav-link nav-link-frontpage" href="/">home</a></li><li class="nav-item"><a class="nav-link nav-link-contact" href="/contact/">contact</a></li><li class="nav-item"><a class="nav-link nav-link-lifestream" href="/lifestream/">lifestream</a></li><li class="nav-item"><a class="nav-link nav-link-blog" href="/w/">blog</a></li></div></ul></div></nav><div class="card hyperbola-section-title my-3 w-100"><div class="card-body"><span class="card-title"><strong>hyperbo.la :: Reflections on Learning Rust By Building Punchtop</strong></span></div></div><div class="row"><div class="col-lg-9 mx-auto"><div class="card mb-3"><div class="card-body"><h2 class="card-title text-center"><a href="/w/reflections-on-learning-rust/">Reflections on Learning Rust By Building Punchtop</a></h2><div class="h6 card-subtitle text-center mb-2 hyperbola-text-timestamp"><a href="/contact/">Ryan Lopopolo</a> | January 27, 2019</div><div class="card-text"><p><a href="https://github.com/lopopolo/punchtop">Punchtop</a> is an <a href="https://en.wikipedia.org/wiki/Power_hour">audio game</a> that uses a Chromecast as an audio output device. I have implemented this game <a href="https://github.com/lopopolo/powerhour">a few times before</a>; the rules are simple and I have a lot of practice implementing my ideal architecture, which makes it a good candidate for learning new languages and libraries. Punchtop is about 3700 lines of Rust and JavaScript:</p><pre><code class="hljs language-console"><span class="hljs"><span class="hljs-meta">$</span><span class="bash"> (find . -name <span class="hljs-string">&#x27;*.rs&#x27;</span> -not -path <span class="hljs-string">&#x27;*target*&#x27;</span> -not -path <span class="hljs-string">&#x27;*proto*&#x27;</span> | xargs cat) \</span>
    | wc -l
    3104
<span class="hljs-meta">$</span><span class="bash"> (find . -name <span class="hljs-string">&#x27;*.js&#x27;</span> -not -path <span class="hljs-string">&#x27;*target*&#x27;</span> -not -path <span class="hljs-string">&#x27;*node_modules*&#x27;</span> | xargs cat) \</span>
    | wc -l
     563</span></code></pre><p>For context, my most comfortable languages are Ruby and Python. I also have written significant amounts of code in Golang, Java, JavaScript, Objective-C, PHP, and Scala. While I have been meaning to learn Rust <a href="https://hyperbo.la/lifestream/298/">since at least 2014</a>, this was my first time sitting down with the language. In this post I&#39;ll reflect on what I liked, what I didn&#39;t, what I found easy, and what I found hard.</p><h3 id="language">Language</h3><p>My overall impression of Rust is that it is pleasant to work with once you grok the memory model. Despite the language being low level, I only had two panics during development. I felt comfortable in the same way I do when developing Scala (and that I don&#39;t in Ruby or Golang): if the code compiles, it is likely to be correct.</p><h4 id="borrow-checker">Borrow Checker</h4><p>The borrow checker was a new concept for me. My previous implementation of this game was an <a href="https://github.com/lopopolo/powerhour/tree/master/pwrhr">evented ruby implementation</a> which was (ahem) cavalier in how it shared object references. I initially fought with the compiler a lot, but some practice helped me get into my head when to use references, when to <code>clone</code>, and when to <code>move</code>. I tried to read some tutorials on borrowing and none of it stuck. I had to get comfortable by doing.</p><h4 id="memory-safety">Memory Safety</h4><p>The most practical consequence of Rust&#39;s memory safety is that there is no <code>null</code>. Having this baked into the language (and the standard library!) is liberating. Whole classes of bugs vanish because using <code>Option</code> and <code>Result</code> is not only the default, but required.</p><h4 id="clippy">Clippy</h4><p>While not part of rustc proper, <a href="https://github.com/rust-lang/rust-Clippy">Clippy</a> is a rustup component that acts as a linter. I found Clippy to be incredibly useful while learning the language. Its large library of lints helped me to internalize how to write idiomatic Rust. Early on, I added <code>#![warn(clippy::all, clippy::pedantic)]</code> to my crate.</p><p>Clippy helped me write more performant code by suggesting the correct combinators to use, e.g. <code>map_or</code> instead of <code>map(...).unwrap_or_else(...)</code>, and avoiding unnecessary clones by using references when functions did not consume arguments.</p><p>Clippy helped me write more correct code by forcing me to correctly handle <a href="https://github.com/lopopolo/punchtop/blob/d1f69dc20c4a6faaa65fc8ec854a452738f19194/src/playlist/fs/mod.rs#L99-L119">overflow</a> (this code is gross; it gets much better in <a href="https://github.com/lopopolo/punchtop/commit/2a8ddbfb6e22fa29eaef20ecdd264a865a1f1d4b">2a8ddbfb</a>) and safely convert between <a href="https://github.com/lopopolo/punchtop/commit/189b7fa3e7c9abcd561b6592d58235ff426b9c6f"><code>usize</code> and <code>u64</code></a>.</p><h5 id="clippy-gotchas">Clippy Gotchas</h5><p>Clippy required nightly to analyze all of the crates that Punchtop depended on, which was initially off-putting. Requiring nightly also interacted poorly with the <code>protobuf-codegen-pure</code> build dependency: the codegen only output <code>#![allow(clippy)]</code> in the generated build files, which was <a href="https://github.com/stepancheg/rust-protobuf/pull/332">incompatible with nightly Clippy</a>. I wrote a <a href="https://github.com/lopopolo/punchtop/blob/d1f69dc20c4a6faaa65fc8ec854a452738f19194/build.rs#L64-L75">codemod</a> in <code>build.rs</code> to work around this (I wish I could have found a library that did this for me).</p><p>Clippy offers the ability to selectively disable lints by attaching an <code>#[allow(clippy::...)]</code> to any code unit. I had to do this in a few places: <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/cast-client/src/lib.rs#L21-L22">generated protobufs</a>, some <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/cast-client/src/channel/media.rs#L80-L147">serde enums</a>, and <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/punchtop-audio/src/chromecast/media_server.rs#L47-L55">rocket route functions</a>. Selectively disabling lints was not hard, but it was non-obvious.</p><p>The most frustrating part of using Clippy is that it did not force a reanalysis of all packages in my cargo workspace when invoked multiple times. A (maybe bad?) habit I learned from rubocop is to incrementally fix lint errors and rerun the linter to see what I have left. Clippy does not force a re-compile of source packages in the current workspace requiring contortions like <code>touch src/main.rs</code> to get the updated lint errors.</p><p>Overall, I found Clippy to be quite excellent and it made my Rust code much better.</p><h4 id="refactoring">Refactoring</h4><p>My initial implementation of Punchtop used <a href="https://docs.rs/rodio/0.8.1/rodio/">rodio</a> as the audio output device. Once I added the <a href="https://github.com/lopopolo/punchtop/tree/7a7354cbe56608f274a00ec6904cd434a5616c7c/punchtop-audio/src/chromecast">Chromecast sink</a>, the shared API for these two modules evolved rapidly (especially once the API started to get infected by async). I found that the rodio implementation was slowing me down too much, so I deleted it. Looking back, a better solution would have been to add a <code>#[cfg(...)]</code> incantation to disable compilation for the rodio-based module.</p><h4 id="testing">Testing</h4><p>I have <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/stream-util/src/lib.rs#L294-L498">some tests</a>! which is more than I can normally say about a side project. I found it much easier to write tests for a few reasons:</p><ol><li>Tests are defined inline with the rest of the code in my modules, which eliminated some context switching and made it easy to write tests as I implemented functionality.</li><li><code>#[test]</code> is native to rustc, so I did not have to mess with choosing a unit test framework and getting it integrated with my project.</li><li>I only had to learn two bits of magic to write a test since they are just regular functions (and even the magic is very straightforward): annotating test functions with <code>#[test]</code> and the <code>assert_eq!</code> macro.</li></ol><p><a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/stream-util/src/lib.rs#L38-L65">Doc tests are amazing</a>. They made me confident in my documentation and led to a <a href="https://github.com/lopopolo/punchtop/tree/7a7354cbe56608f274a00ec6904cd434a5616c7c/stream-util">higher quality README</a>.</p><h5 id="testing-gotchas">Testing Gotchas</h5><p>The only non-obvious part of writing tests was wrapping test functions in a <code>mod test</code> that is conditionally compiled during test builds with <code>#[cfg(test)]</code>. The <a href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html">Rust book section on testing</a> has examples that show to do this, but never specifies <em>why</em> to do it. The answer is decreased compilation time in non-test builds.</p><h4 id="documentation">Documentation</h4><p><code>cargo doc</code> is excellent. I ran this on an airplane and was able to develop with no Internet access.</p><p>The <a href="https://github.com/lopopolo/punchtop/tree/7a7354cbe56608f274a00ec6904cd434a5616c7c/stream-util">stream-util</a> module I wrote to gracefully drain a futures mpsc channel is the most well-documented module I have ever written. I added a directive to <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/stream-util/src/lib.rs#L1">fail builds on missing docs</a>. I modeled the docs on those in <a href="https://github.com/BurntSushi/walkdir/blob/master/src/lib.rs">BurntSushi/walkdir</a> and also ported them over to the README for the crate. Like I said above, doc tests are amazing.</p><h5 id="documentation-gotchas">Documentation Gotchas</h5><p>Linking to code units in rustdoc was hard to do correctly since there were so many ways to do it. It took me more than a few attempts to get the resolution rules internalized.</p><p>When porting the rustdoc to the README, I had to manually insert links that resolved the modules in external crates (mostly tokio) that were pertinent to using the library.</p><p>My biggest frustration with <em>reading</em> documentation was using the Rust book(s) from Google. The books themselves are excellent, but the SEO is terrible. There are multiple versions linked in Google. The books <strong>know</strong> that I want the most recent version because they all link to it, but I&#39;d prefer this be handled via a redirect so Google knows what documentation is current.</p><h4 id="cargo">Cargo</h4><p>Cargo is the Yarn equivalent for Rust. It handles managing dependencies, building your code, and running your code. Cargo is very pleasant to work with. Pulling in libraries was effortless (even <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/punchtop-playlist/Cargo.toml#L20-L21">git dependencies</a>), as was <a href="https://github.com/lopopolo/punchtop#usage">running code in either debug or release configurations</a>.</p><p>Rust 2018 Edition came out early on when developing Punchtop and Cargo made it easy to upgrade to the latest supported idioms.</p><p>One thing I missed from Yarn was an <code>outdated</code> command that enumerates libraries that have available updates. I supported this part of my workflow with the <a href="https://github.com/kbknapp/cargo-outdated">cargo-outdated</a> crate which does the job admirably.</p><h4 id="workspaces">Workspaces</h4><p>As Punchtop grew more complex, I had several trees within <code>src</code> that were shaped like independent libraries. I split my monolithic <code>punchtop</code> crate into multiple crates within a shared cargo workspace.</p><p>Moving to a workspace allowed me to consider implementing multiple UI frontends by reusing the <a href="https://github.com/lopopolo/punchtop/tree/7a7354cbe56608f274a00ec6904cd434a5616c7c/punchtop-audio">audio backend</a> and <a href="https://github.com/lopopolo/punchtop/tree/7a7354cbe56608f274a00ec6904cd434a5616c7c/stream-util">stream manipulation</a> libraries I created.</p><p>I also found that splitting libraries out into their own crates made it easier to reason about the visibility of structs and functions without having to mess with more exotic visibility modifiers.</p><h5 id="workspaces-gotchas">Workspaces Gotchas</h5><p>When I split Punchtop into multiple crates, I missed that I needed to add my Clippy <code>!#[warn(...)]</code> directive to the <code>lib.rs</code> of the new crates.</p><h3 id="libraries">Libraries</h3><p>Rust has many good libraries. I was able to offload lots of tricky logic to crates. For example, I do not want to be in the business of <a href="https://github.com/mozilla/mp4parse-rust">parsing an mp4</a> to find out if it is at least 60 seconds long.</p><h4 id="tokio">tokio</h4><p><a href="https://docs.rs/tokio/0.1.15/tokio/">Tokio</a> is a suite of libraries for writing async code. It is big, but was mostly easy to use. These are the highlights.</p><p>The <code>tokio</code> crate is composed of many sub crates, e.g. <code>tokio-timer</code> and <code>tokio-codec</code>. I initially had a mix of these included in Punchtop and was confused by the differing version numbers. Ultimately I learned that tokio <a href="https://github.com/tokio-rs/tokio#project-layout">recommends</a> depending on <code>tokio</code> in crates with a <code>main.rs</code> and the sub crates in crates with a <code>lib.rs</code>. I used this newfound knowledge to <a href="https://github.com/asomers/futures-locks/pull/10">trim 48 dependencies</a> from the <code>futures-locks</code> crate.</p><p><code>tokio-codec</code> is my favorite part of Tokio. <code>tokio-codec</code> enables <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/cast-client/src/lib.rs#L133">reading and writing frames to a socket</a>. The cast protocol consists of <code>u32</code>-length prefixed protobuf frames so this was a perfect fit. It was very easy to implement a <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/cast-client/src/codec.rs#L100-L150">stateful decoder</a>. My encoder consumed a high-level playback command enum and the decoder produced decoded protobufs which were handled by the <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/cast-client/src/channel/mod.rs#L79-L89">channel multiplexer</a>. The separation of concerns made it clear where to check protocol invariants such as <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/cast-client/src/codec.rs#L80-L82">maximum payload size</a>.</p><p>The one gotcha of <code>tokio-codec</code> was the <code>bytes</code> crate. I was missing a call to <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/cast-client/src/codec.rs#L115"><code>buf.reserve(len)</code></a>, which was the source of one of my panics.</p><p>Much has been <a href="https://theta.eu.org/2017/08/04/async-rust.html">written</a> about the <code>futures</code> crate. The two things I found helped me the most when using it are <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/cast-client/src/task.rs#L59-L64"><code>impl trait</code></a> and <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/stream-util/src/lib.rs#L230-L240"><code>IntoFuture</code> combined with generics</a>. I would like to invest more in using <a href="https://github.com/lopopolo/punchtop/blob/1e41ca3c613ef67ec7c4491cc4941a5ef551955d/stream-util/src/lib.rs#L144-L157">named <code>Future</code>s</a> to clean up the <code>cast-client</code> public API.</p><h4 id="web_view">web_view</h4><p>The state of writing GUIs in Rust is still developing. <a href="https://azul.rs/">Azul</a> (based on WebRender) looks promising but is super alpha. The <a href="https://github.com/servo/core-foundation-rs/">Cocoa bindings</a> used in Servo require writing lots of unsafe code.</p><p><a href="https://github.com/Boscop/web-view">web_view</a> provides high-level Rust bindings for the cross-platform <a href="https://github.com/zserge/webview">webview single-header C library</a>. The library allows two-way communication to JS running in the webview using stringified JSON. I built a <a href="https://github.com/lopopolo/punchtop/tree/7a7354cbe56608f274a00ec6904cd434a5616c7c/punchtop-react">React and Redux app</a> and a minimal amount of <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/punchtop-webview/src/app/mod.rs">MVC glue</a> to track application state in Rust. The result was an easy to extend UI. I even integrated the webpack build into the <a href="https://github.com/lopopolo/punchtop/blob/master/punchtop-webview/build.rs">build script</a> for <code>punchtop-webview</code>.</p><h4 id="log-and-env_logger">log and env_logger</h4><p><a href="https://docs.rs/log/0.4.6/log/">Logging</a> was super <a href="https://docs.rs/env_logger/0.6.0/env_logger/">easy to set up</a> and achieved good results by default. The <code>debug!</code> and <code>warn!</code> macros have obvious meaning and do not interrupt the flow of the code.</p><p>My one complaint is that <code>RUST_LOG=debug cargo run</code> dumps all of the verbose debug logs from <em>cargo</em> while your program is being built.</p><h4 id="rocket">rocket</h4><p><a href="https://rocket.rs/">Rocket</a> is a <a href="https://hyper.rs/">hyper</a>-based HTTP framework. Rocket requires nightly, but is very ergonomic to use. It requires <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/punchtop-audio/src/chromecast/media_server.rs#L45-L90">less ceremony than even a Sinatra server</a>. The statically-typed <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/punchtop-audio/src/chromecast/media_server.rs#L47-L55">route functions</a> were pleasant to work with.</p><p>I did have to jump through some hoops to use Rocket as an embedded (vs. application) server, including <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/punchtop-audio/src/chromecast/media_server.rs#L83-L88">launching rocket in a thread</a> instead of scheduling it on my tokio reactor, <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/punchtop-audio/src/chromecast/media_server.rs#L96-L115">discovering the bind interface</a>, and configuring an <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/punchtop-audio/src/chromecast/media_server.rs#L117-L122">unused secret key</a>.</p><h4 id="mp3_duration">mp3_duration</h4><p><a href="https://github.com/agersant/mp3-duration">mp3_duration</a> is a single-purpose crate did exactly what I needed it to do until it panicked on some of my MP3s. Since I was using this crate to filter items out of a playlist, I <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/punchtop-playlist/src/fs/mod.rs#L71-L85">isolated it</a> using <code>panic::catch_unwind</code> and ignored files it could not parse. I should probably find a panicking sample MP3 and file a GitHub issue.</p><h4 id="serde">serde</h4><p><a href="https://serde.rs/">Serde</a> is my favorite of all the crates I used in Punchtop. I have previous experience with statically-typed JSON libraries in <a href="https://github.com/FasterXML/jackson">Jackson</a> and <a href="https://github.com/json4s/json4s">json4s</a>. Serde is by far the easiest JSON library to work with.</p><p>Serde uses Rust macro magic to derive encoders and decoders directly from structs. The encoder and decoder are configurable with a few other macros. My two favorites are <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/cast-client/src/channel/media.rs#L122-L128">remapping rustfmt-compliant struct fields to the native JSON camel case style</a> and <a href="https://github.com/lopopolo/punchtop/blob/7a7354cbe56608f274a00ec6904cd434a5616c7c/cast-client/src/channel/media.rs#L81">field-tagged enums</a> AKA switching deserialization based on a type tag in the JSON. Field-tagged enums gives you all the benefits of Rust enums when dealing with JSON, most notably ensuring match arms are exhaustive.</p><h3 id="moving-forward">Moving Forward</h3><p>At this point in the project, I feel reasonably comfortable working with Rust, but there are still lots of things left to learn. My next goal is to write a native Cocoa frontend for Punchtop which means either using the <code>objc</code> and <code>cocoa</code> crates or embedding <code>cast-client</code> into a Swift app via FFI. Either way, I am excited to make more progress.</p></div></div></div></div></div></div><script src="/main.57e4ff55d4eb66372f98.js"></script></body></html>