<!doctype html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"/><title>hyperbo.la :: Cactus Harvesting: Cycle-Aware Reference Counting in Rust</title><meta property="og:site_name" content="hyperbo.la"/><meta property="og:url" content="https://hyperbo.la/w/cactus-harvesting/"/><meta property="og:image" content="https://hyperbo.la/logo.png"/><meta property="og:type" content="article"/><meta property="og:article:published_time" content="2019-07-15T00:00:00.000+00:00"/><meta property="og:article:modified_time" content="2019-07-15T00:00:00.000+00:00"/><meta property="og:article:author" content="https://www.facebook.com/ryan.lopopolo"/><meta property="og:title" content="Cactus Harvesting: Cycle-Aware Reference Counting in Rust"/><meta property="og:description" content="ðŸŒµ CactusRef lets you build cyclic data structures using strong references and knows how to deallocate unreachable cycles. You can use CactusRef to implement a doubly linked list. The CactusRef API is compatible with std::rc."/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><meta name="msapplication-TileColor" content="#222222"/><meta name="theme-color" content="#222222"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-30651847-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-30651847-1")</script><link href="/main.cd829ba5789a0495279a.css" rel="stylesheet"></head><body class="blog"><div class="container mb-5"><nav class="navbar navbar-expand-lg p-0"><div class="container d-flex flex-row justify-content-between p-0"><a class="navbar-brand p-0" href="/" aria-label="hyperbola"><img class="float-left" title="hyperbola" alt="Hyperbola logo" src="/ea3a0c4f0b6d4c1600f0444f02ac44d9.svg"/> <span class="sr-only">hyperbola</span> </a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse mt-auto" id="navbarSupportedContent"><ul class="navbar-nav ml-auto"><div class="container d-flex flex-column flex-md-row justify-content-end align-items-stretch text-center"><li class="nav-item"><a class="nav-link nav-link-frontpage" href="/">home</a></li><li class="nav-item"><a class="nav-link nav-link-contact" href="/contact/">contact</a></li><li class="nav-item"><a class="nav-link nav-link-lifestream" href="/lifestream/">lifestream</a></li><li class="nav-item"><a class="nav-link nav-link-blog" href="/w/">blog</a></li></div></ul></div></div></nav><div class="card hyperbola-section-title my-3 w-100"><div class="card-body"><span class="card-title"><strong>hyperbo.la :: Cactus Harvesting: Cycle-Aware Reference Counting in Rust</strong></span></div></div><div class="row"><div class="col-lg-9 mx-auto"><div class="card mb-3"><div class="card-body"><h2 class="card-title text-center"><a href="/w/cactus-harvesting/">Cactus Harvesting: Cycle-Aware Reference Counting in Rust</a></h2><div class="h6 card-subtitle text-center mb-2 text-muted"><a href="/contact/">Ryan Lopopolo</a> | July 15, 2019</div><div class="card-text"><p>ðŸŒµ CactusRef is a single-threaded, cycle-aware, reference counting smart pointer [<a href="https://lopopolo.github.io/ferrocarril/cactusref/index.html">docs</a>] [<a href="https://github.com/lopopolo/ferrocarril/tree/0052dc1d0b234c2535b8dd87a096e048bdc0819e/cactusref">code</a>]. CactusRef is nearly a drop-in replacement for <a href="https://doc.rust-lang.org/std/rc/index.html"><code>std::rc</code></a> from the Rust standard library. (CactusRef implements all <code>std::rc::Rc</code> APIs except for <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html#method.downcast"><code>std::rc::Rc::downcast</code></a>, <a href="https://doc.rust-lang.org/nightly/core/ops/trait.CoerceUnsized.html"><code>CoerceUnsized</code></a>, and <a href="https://doc.rust-lang.org/nightly/core/ops/trait.DispatchFromDyn.html"><code>DispatchFromDyn</code></a>.) Throughout this post, <code>Rc</code> refers to <code>cactusref::Rc</code>. I will refer to <code>std::rc::Rc</code> with its fully qualified name.</p><h3 id="motivation">Motivation</h3><p>Building cyclic data structures in Rust is <a href="https://news.ycombinator.com/item?id=16443688">hard</a>. When a <code>T</code> needs to have multiple owners, it can be wrapped in a <a href="https://doc.rust-lang.org/std/rc/index.html"><code>std::rc::Rc</code></a>. <code>std::rc::Rc</code>, however, is not cycle-aware. Creating a cycle of <code>std::rc::Rc</code>s will leak memory. To work around this, an <code>std::rc::Rc</code> can be <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html#method.downgrade">downgraded</a> into a <a href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>std::rc::Weak</code></a>.</p><h3 id="stdrcrc-limitations"><code>std::rc::Rc</code> Limitations</h3><p>Strong references are much more convenient to work with than weak references. Imagine the following code (written in Ruby) to create a ring:</p><pre><code class="hljs language-ruby"><span class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span>
  <span class="hljs-keyword">attr_accessor</span> <span class="hljs-symbol">:next</span>
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ring</span></span>
  n1 = Node.new
  n2 = Node.new
  n3 = Node.new

  n1.<span class="hljs-keyword">next</span> = n2
  n2.<span class="hljs-keyword">next</span> = n3
  n3.<span class="hljs-keyword">next</span> = n1

  n1
<span class="hljs-keyword">end</span>

head = ring</span></code></pre><p>This code is quite difficult to write with <code>std::rc::Rc</code> and <code>std::rc::Weak</code> because the ring wants to own references. If we used <code>std::rc::Weak</code> to implement <code>next</code>, after <code>ring</code> returns, <code>n2</code> and <code>n3</code> would be dropped and the <code>std::rc::Weak</code>s in the object graph would be dangling.</p><p><code>n1</code>, <code>n2</code>, and <code>n3</code> form a cycle. This cycle is <em>reachable</em> because <code>n1</code> is also bound to the variable <code>head</code>. The strong count of <code>n1</code> is two, which is greater than the number of times it is owned by nodes in the cycle (only <code>n3</code> owns <code>n1</code>). <code>n2</code> and <code>n3</code> should not be deallocated because they are in a cycle with <code>n1</code>. Because <code>n1</code> is externally reachable, the entire cycle is externally reachable.</p><p>If we instead write this code:</p><pre><code class="hljs language-ruby"><span class="hljs">head = ring
head = <span class="hljs-literal">nil</span>
<span class="hljs-comment"># the cycle is unreachable and should be deallocated</span></span></code></pre><p>The cycle is <em>orphaned</em> because the only strong references to nodes in the cycle come from other nodes in the cycle. The cycle is safe to deallocate and should be reaped.</p><h3 id="rust-example-doubly-linked-list">Rust Example: Doubly Linked List</h3><p>CactusRef can be used to <a href="https://github.com/lopopolo/ferrocarril/blob/53b4048628cd5577e378ce4fdae73a923340dcd1/cactusref/tests/no_leak_doubly_linked_list.rs">implement a doubly linked list</a> with ergonomic strong references. The list is deallocated when the <code>list</code> binding is dropped because the linked list is no longer externally reachable.</p><pre><code class="hljs language-rust"><span class="hljs"><span class="hljs-keyword">use</span> cactusref::{Adoptable, Rc};
<span class="hljs-keyword">use</span> std::cell::RefCell;
<span class="hljs-keyword">use</span> std::iter;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span>&lt;T&gt; {
    <span class="hljs-keyword">pub</span> prev: <span class="hljs-built_in">Option</span>&lt;Rc&lt;RefCell&lt;<span class="hljs-keyword">Self</span>&gt;&gt;&gt;,
    <span class="hljs-keyword">pub</span> next: <span class="hljs-built_in">Option</span>&lt;Rc&lt;RefCell&lt;<span class="hljs-keyword">Self</span>&gt;&gt;&gt;,
    <span class="hljs-keyword">pub</span> data: T,
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">List</span></span>&lt;T&gt; {
    <span class="hljs-keyword">pub</span> head: <span class="hljs-built_in">Option</span>&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;,
}

<span class="hljs-keyword">impl</span>&lt;T&gt; List&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">pop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt; {
        <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">self</span>.head.take()?;
        <span class="hljs-keyword">let</span> tail = head.borrow_mut().prev.take();
        <span class="hljs-keyword">let</span> next = head.borrow_mut().next.take();
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-keyword">ref</span> tail) = tail {
            Rc::unadopt(&amp;head, &amp;tail);
            Rc::unadopt(&amp;tail, &amp;head);
            tail.borrow_mut().next = next.as_ref().map(Rc::clone);
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-keyword">ref</span> next) = next {
                Rc::adopt(tail, next);
            }
        }
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-keyword">ref</span> next) = next {
            Rc::unadopt(&amp;head, &amp;next);
            Rc::unadopt(&amp;next, &amp;head);
            next.borrow_mut().prev = tail.as_ref().map(Rc::clone);
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-keyword">ref</span> tail) = tail {
                Rc::adopt(next, tail);
            }
        }
        <span class="hljs-keyword">self</span>.head = next;
        <span class="hljs-literal">Some</span>(head)
    }
}

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">From</span>&lt;<span class="hljs-built_in">Vec</span>&lt;T&gt;&gt; <span class="hljs-keyword">for</span> List&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>(list: <span class="hljs-built_in">Vec</span>&lt;T&gt;) -&gt; <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">let</span> nodes = list
            .into_iter()
            .map(|data| {
                Rc::new(RefCell::new(Node {
                    prev: <span class="hljs-literal">None</span>,
                    next: <span class="hljs-literal">None</span>,
                    data,
                }))
            })
            .collect::&lt;<span class="hljs-built_in">Vec</span>&lt;_&gt;&gt;();
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..nodes.len() - <span class="hljs-number">1</span> {
            <span class="hljs-keyword">let</span> curr = &amp;nodes[i];
            <span class="hljs-keyword">let</span> next = &amp;nodes[i + <span class="hljs-number">1</span>];
            curr.borrow_mut().next = <span class="hljs-literal">Some</span>(Rc::clone(next));
            next.borrow_mut().prev = <span class="hljs-literal">Some</span>(Rc::clone(curr));
            Rc::adopt(curr, next);
            Rc::adopt(next, curr);
        }
        <span class="hljs-keyword">let</span> tail = &amp;nodes[nodes.len() - <span class="hljs-number">1</span>];
        <span class="hljs-keyword">let</span> head = &amp;nodes[<span class="hljs-number">0</span>];
        tail.borrow_mut().next = <span class="hljs-literal">Some</span>(Rc::clone(head));
        head.borrow_mut().prev = <span class="hljs-literal">Some</span>(Rc::clone(tail));
        Rc::adopt(tail, head);
        Rc::adopt(head, tail);

        <span class="hljs-keyword">let</span> head = Rc::clone(head);
        <span class="hljs-keyword">Self</span> { head: <span class="hljs-literal">Some</span>(head) }
    }
}

<span class="hljs-keyword">let</span> list = iter::repeat(())
    .map(|_| <span class="hljs-string">&quot;a&quot;</span>.repeat(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>))
    .take(<span class="hljs-number">10</span>)
    .collect::&lt;<span class="hljs-built_in">Vec</span>&lt;_&gt;&gt;();
<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> list = List::from(list);
<span class="hljs-keyword">let</span> head = list.pop().unwrap();
<span class="hljs-built_in">assert_eq!</span>(Rc::strong_count(&amp;head), <span class="hljs-number">1</span>);
<span class="hljs-built_in">assert_eq!</span>(list.head.as_ref().map(Rc::strong_count), <span class="hljs-literal">Some</span>(<span class="hljs-number">3</span>));
<span class="hljs-keyword">let</span> weak = Rc::downgrade(&amp;head);
<span class="hljs-built_in">drop</span>(head);
<span class="hljs-built_in">assert!</span>(weak.upgrade().is_none());
<span class="hljs-built_in">drop</span>(list);
<span class="hljs-comment">// all memory consumed by the list nodes is reclaimed.</span></span></code></pre><h3 id="cactusref-implementation">CactusRef Implementation</h3><p>There are two magic pieces to CactusRef: <code>Rc</code> adoption and the cycle-busting <a href="https://lopopolo.github.io/ferrocarril/cactusref/struct.Rc.html#impl-Drop"><code>Drop</code></a> implementation.</p><h4 id="adoption">Adoption</h4><p>When an <code>Rc&lt;T&gt;</code> takes and holds an owned reference to another <code>Rc&lt;T&gt;</code>, calling <a href="https://lopopolo.github.io/ferrocarril/cactusref/struct.Rc.html#impl-Adoptable"><code>Rc::adopt</code></a> performs bookkeeping to build a graph of reachable objects. There is an unlinking API, <code>Rc::unadopt</code>, which removes a reference from the graph.</p><p>An <code>Rc&lt;T&gt;</code> is able to adopt another <code>Rc&lt;T&gt;</code> multiple times. An <code>Rc&lt;T&gt;</code> is able to adopt <em>itself</em> multiple times. Together, these behaviors allow implementing the following Ruby structure:</p><pre><code class="hljs language-ruby"><span class="hljs">ary = []
<span class="hljs-comment"># =&gt; []</span>
hash = { ary =&gt; ary }
<span class="hljs-comment"># =&gt; {[]=&gt;[]}</span>
hash[hash] = hash
<span class="hljs-comment"># =&gt; {[]=&gt;[], {...}=&gt;{...}}</span>
ary &lt;&lt; hash &lt;&lt; hash &lt;&lt; ary &lt;&lt; ary
<span class="hljs-comment"># =&gt; [{[...]=&gt;[...], {...}=&gt;{...}}, {[...]=&gt;[...], {...}=&gt;{...}}, [...], [...]]</span>
hash = <span class="hljs-literal">nil</span>
ary = <span class="hljs-literal">nil</span>
<span class="hljs-comment"># all structures are deallocated</span></span></code></pre><p>This bookkeeping is implemented as a set of forward (owned) and backward (owned by) links stored on the data structure that backs the <code>Rc</code> (called an <a href="https://github.com/lopopolo/ferrocarril/blob/53b4048628cd5577e378ce4fdae73a923340dcd1/cactusref/src/ptr.rs#L84-L91"><code>RcBox</code></a>).</p><h4 id="drop">Drop</h4><p>There are three states that <code>Rc</code> needs to deal with on <code>Drop</code> in this order:</p><ol><li><code>Rc</code> is unreachable and does not own any others. In this case, <code>Rc::strong_count</code> is zero and the set of forward links is empty.</li><li><code>Rc</code> is part of an orphaned cycle. In this case, <code>Rc::strong_count</code> is greater than zero and the <code>Rc</code> has some forward or back links.</li><li><code>Rc</code> is unreachable and has adopted links. In this case, <code>Rc::strong_count</code> is zero and the set of forward links is non-empty.</li></ol><p>Each case is implemented with these steps:</p><ol><li>Bust forward and back links on this <code>Rc</code>&#39;s back links.</li><li>Bust forward and back links on this <code>Rc</code>.</li><li>Mark all reachable <code>Rc</code>s as killed.</li><li>Drop strong references.</li><li>Decrement the implicit &quot;strong weak&quot; pointer.</li><li>Deallocate.</li></ol><p>The interesting case is state 2 which requires knowing whether this <code>Rc</code> is part of an <em>orphaned cycle</em>. <code>Drop</code> detects whether this <code>Rc</code> is a member of a cycle by performing breadth first search over the total set of forward and back links in the object graph. The cycle detection algorithm tracks the reachability of each node in the cycle by other cycle members. Forward links contribute toward reachability. Backward references do not contribute but are added to the set of nodes to traverse in the reachability analysis. Cycle detection is <code>O(links)</code> where links is the number of active adoptions.</p><p>To determine whether the cycle is orphaned, the intra-cycle ownership counts are compared to the strong count of each node. If the strong count for a node is greater than the number of links the cycle has to that node, the node is externally reachable and the cycle is not orphaned. Detecting an orphaned cycle is <code>O(links + nodes)</code> where links is the number of active adoptions and nodes is the number of <code>Rc</code>s in the cycle.</p><p><a href="https://github.com/lopopolo/ferrocarril/blob/53b4048628cd5577e378ce4fdae73a923340dcd1/cactusref/src/cycle/drop.rs#L163-L217">Deallocating an orphaned cycle</a> is <em>fun</em> and filled with unsafe peril. It is guaranteed that at least one other object in the cycle owns a reference to this <code>Rc</code>, so as we deallocate members of the cycle, this <code>Rc</code> will be dropped again.</p><p>Dropping this <code>Rc</code> multiple times is good because it manages decrementing the strong count of this <code>Rc</code> automatically. This ensures that any outstanding <code>Weak</code> pointers detect that they are dangling and return <code>None</code> on <code>Weak::upgrade</code>. However, it will also certainly result in a <a href="https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Common_errors">double-free or use-after-free</a> if we are not careful.</p><p>To avoid a double-free, the <code>RcBox</code> includes a <code>usize</code> field called <code>tombstone</code>. When we attempt to drop an <code>Rc</code> in the cycle we <a href="https://github.com/lopopolo/ferrocarril/blob/53b4048628cd5577e378ce4fdae73a923340dcd1/cactusref/src/cycle/drop.rs#L182-L193">mark it as killed</a>. Subsequent calls to <code>drop</code> on killed <code>Rc</code>s early return after decrementing the strong count.</p><p>To avoid a use-after-free, on drop, an <code>Rc</code> <a href="https://github.com/lopopolo/ferrocarril/blob/53b4048628cd5577e378ce4fdae73a923340dcd1/cactusref/src/cycle/drop.rs#L168-L181">removes itself from all link tables</a> so it is not used for cycle detection.</p><p>To do the deallocation, <a href="https://github.com/lopopolo/ferrocarril/blob/53b4048628cd5577e378ce4fdae73a923340dcd1/cactusref/src/cycle/drop.rs#L194-L205">drop the <em>values</em> in the <code>Rc</code>s</a> instead of the <code>Rc</code>s. This breaks the cycle during the deallocation and allows <code>Drop</code> to crawl the object graph.</p><h3 id="cycle-detection-is-a-zero-cost-abstraction">Cycle Detection Is a Zero-Cost Abstraction</h3><p>Cycle detection is a zero-cost abstraction. If you never <code>use cactusref::Adoptable;</code>, <code>Drop</code> uses the same implementation as <code>std::rc::Rc</code> (and leaks in the same way as <code>std::rc::Rc</code> if you form a cycle of strong references). The only costs you pay are the memory costs of one <a href="https://doc.rust-lang.org/nightly/core/cell/struct.Cell.html"><code>Cell&lt;usize&gt;</code></a> for preventing double frees, two empty <a href="https://doc.rust-lang.org/nightly/core/cell/struct.RefCell.html"><code>RefCell</code></a><code>&lt;</code><a href="https://doc.rust-lang.org/nightly/std/collections/struct.HashMap.html"><code>HashMap</code></a><code>&lt;NonNull&lt;T&gt;, usize&gt;&gt;</code> for tracking adoptions, and an if statement to check if these structures are empty on <code>drop</code>.</p><h3 id="next-steps">Next Steps</h3><p>I am <a href="https://github.com/lopopolo/ferrocarril">implementing a Ruby</a> ðŸ’Ž in Rust and CactusRef will be used to implement the heap. CactusRef allows Ruby objects to own strong references to their subordinate members (like instance variables, keys and values in the case of a <code>Hash</code>, items in the case of an <code>Array</code>, class, ancestor chain, and bound methods) and be automatically reaped once they become unreachable in the VM.</p><p>CactusRef allows implementing a Ruby without a garbage collector, although if you squint, CactusRef implements a tracing garbage collector using Rust&#39;s built-in memory management.</p><p>Thank you <a href="https://github.com/tummychow">Stephen</a> and <a href="https://github.com/nelhage">Nelson</a> for helping me think hard about algorithms. ðŸ˜„</p><p>Thank you to the segfaults along the way for helping me find bugs in the cycle detection and drop implementations. ðŸ˜±</p></div></div></div></div></div></div><script src="/main.4944a716fbf817de351f.js"></script></body></html>