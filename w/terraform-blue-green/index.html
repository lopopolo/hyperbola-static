<!doctype html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"/><title>hyperbo.la :: Blue-Green Deployments With Autoscaling Groups and Terraform</title><meta property="og:site_name" content="hyperbo.la"/><meta property="og:url" content="https://hyperbo.la/w/terraform-blue-green/"/><meta property="og:image" content="https://hyperbo.la/logo.png"/><meta property="og:type" content="article"/><meta property="og:article:published_time" content="2018-11-05T00:00:00.000+00:00"/><meta property="og:article:modified_time" content="2018-11-05T00:00:00.000+00:00"/><meta property="og:article:author" content="https://www.facebook.com/ryan.lopopolo"/><meta property="og:title" content="Blue-Green Deployments With Autoscaling Groups and Terraform"/><meta property="og:description" content="Moving blue-green deployments into terraform-managed autoscaling groups makes rolling out new AMIs easier."/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><meta name="msapplication-TileColor" content="#222222"/><meta name="theme-color" content="#222222"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-30651847-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-30651847-1")</script><link href="/main.cd829ba5789a0495279a.css" rel="stylesheet"></head><body class="blog"><div class="container mb-5"><nav class="navbar navbar-expand-lg p-0"><div class="container d-flex flex-row justify-content-between p-0"><a class="navbar-brand p-0" href="/" aria-label="hyperbola"><img class="float-left" title="hyperbola" alt="Artichoke Ruby logo" src="/ea3a0c4f0b6d4c1600f0444f02ac44d9.svg"/> <span class="sr-only">hyperbola</span> </a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse mt-auto" id="navbarSupportedContent"><ul class="navbar-nav ml-auto"><div class="container d-flex flex-column flex-md-row justify-content-end align-items-stretch text-center"><li class="nav-item"><a class="nav-link nav-link-frontpage" href="/">home</a></li><li class="nav-item"><a class="nav-link nav-link-contact" href="/contact/">contact</a></li><li class="nav-item"><a class="nav-link nav-link-lifestream" href="/lifestream/">lifestream</a></li><li class="nav-item"><a class="nav-link nav-link-blog" href="/w/">blog</a></li></div></ul></div></div></nav><div class="card hyperbola-section-title my-3 w-100"><div class="card-body"><span class="card-title"><strong>hyperbo.la :: Blue-Green Deployments With Autoscaling Groups and Terraform</strong></span></div></div><div class="row"><div class="col-lg-9 mx-auto"><div class="card mb-3"><div class="card-body"><h2 class="card-title text-center"><a href="/w/terraform-blue-green/">Blue-Green Deployments With Autoscaling Groups and Terraform</a></h2><div class="h6 card-subtitle text-center mb-2 text-muted"><a href="/contact/">Ryan Lopopolo</a> | November 5, 2018</div><div class="card-text"><p>Blue-green deployments make deploys less risky by running old and new code simultaneously on identical stacks. If there is a problem with the deploy, you can quickly fail back to the previous version.</p><p>One way you can perform a blue-green deployment with an AWS autoscaling group (ASG) involves mutating the ASG configuration and state.</p><ol><li>Create a new launch configuration that points to your new pre-baked AMI.</li><li><a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/change-launch-config.html">Change the launch configuration for your ASG</a>.</li><li>Gradually cycle your ASG by terminating instances running the old AMI.</li><li>If all goes well, your new code is fully rolled out.</li></ol><p>To rollback a bad deploy:</p><ol><li>Change the launch configuration on the ASG back to the old AMI.</li><li>Terminate instances running the new AMI.</li></ol><p>This achieves a gradual rollout, but it requires manually terminating hosts. We can do better with terraform.</p><p>Rather than creating blue and green launch configurations, we can create blue and green ASGs and roll between them. To achieve this with terraform, we configure our launch configuration and ASG with <code>create_before_destroy = true</code> <em>and</em> make the name of the ASG depend on the launch configuration&#39;s generated name. Your terraform config should look something like this:</p><pre><code class="hljs language-terraform"><span class="hljs"><span class="hljs-keyword">resource</span> <span class="hljs-string">&quot;aws_launch_configuration&quot;</span> <span class="hljs-string">&quot;backend&quot;</span> {
  name_prefix     = <span class="hljs-string">&quot;app-backend-&quot;</span>
  image_id        = <span class="hljs-string">&quot;<span class="hljs-variable">${data.aws_ami.backend.id}</span>&quot;</span>
  instance_type   = <span class="hljs-string">&quot;c5.xlarge&quot;</span>
  security_groups = [<span class="hljs-string">&quot;<span class="hljs-variable">${aws_security_group.backend.id}</span>&quot;</span>]

  iam_instance_profile = <span class="hljs-string">&quot;<span class="hljs-variable">${var.iam_instance_profile}</span>&quot;</span>

  lifecycle {
    create_before_destroy = true
  }
}

<span class="hljs-keyword">resource</span> <span class="hljs-string">&quot;aws_autoscaling_group&quot;</span> <span class="hljs-string">&quot;backend&quot;</span> {
  name                  = <span class="hljs-string">&quot;<span class="hljs-variable">${aws_launch_configuration.backend.name}</span>&quot;</span>
  launch_configuration  = <span class="hljs-string">&quot;<span class="hljs-variable">${aws_launch_configuration.backend.name}</span>&quot;</span>
  desired_capacity      = <span class="hljs-string">&quot;<span class="hljs-variable">${var.size}</span>&quot;</span>
  min_size              = <span class="hljs-string">&quot;<span class="hljs-variable">${var.size}</span>&quot;</span>
  max_size              = <span class="hljs-string">&quot;<span class="hljs-variable">${2 * var.size + 1}</span>&quot;</span>
  wait_for_elb_capacity = <span class="hljs-string">&quot;<span class="hljs-variable">${var.size}</span>&quot;</span>

  availability_zones  = [<span class="hljs-string">&quot;<span class="hljs-variable">${data.aws_subnet.private.*.availability_zone}</span>&quot;</span>]
  vpc_zone_identifier = [<span class="hljs-string">&quot;<span class="hljs-variable">${data.aws_subnet.private.*.id}</span>&quot;</span>]
  target_group_arns   = [<span class="hljs-string">&quot;<span class="hljs-variable">${aws_alb_target_group.backend.arn}</span>&quot;</span>]

  lifecycle {
    create_before_destroy = true
  }
}</span></code></pre><p>Writing the config like this forces terraform to create a new ASG every time the we update the launch configuration. A new ASG forces new instances to spin up, which quickly rolls the infra to the latest AMI.</p><p>If we pin the <code>backend</code> AMI to a specific tag, a <code>terraform apply</code> will roll our infrastructure to a new AMI. If the deploy is bad, we can revert by reverting the AMI version bump in code and running <code>terraform apply</code> again.</p><p>We are slightly cheating here because we don&#39;t maintain two copies of the app and it is more costly to rollback. For my blog, ease-of-use wins over availability concerns. Your trade-off space may be different.</p></div></div></div></div></div></div><script src="/main.4944a716fbf817de351f.js"></script></body></html>