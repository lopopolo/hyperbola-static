<!doctype html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"/><title>hyperbo.la :: Source-level Polymorphism in Rust</title><meta property="og:site_name" content="hyperbo.la"/><meta property="og:url" content="https://hyperbo.la/w/source-level-polymorphism/"/><meta property="og:image" content="https://hyperbo.la/logo.png"/><meta property="og:type" content="article"/><meta property="og:article:published_time" content="2020-12-24T00:00:00.000+00:00"/><meta property="og:article:modified_time" content="2020-12-24T00:00:00.000+00:00"/><meta property="og:article:author" content="https://www.facebook.com/ryan.lopopolo"/><meta property="og:title" content="Source-level Polymorphism in Rust"/><meta property="og:description" content="Interface compatibility does not require implementing an interface or a trait. Use compile-time flags and source-compatible APIs to swap out implementations."/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><meta name="msapplication-TileColor" content="#222222"/><meta name="theme-color" content="#222222"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-30651847-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-30651847-1")</script><link href="/main.bf8c28b66d0efedc99b2.css" rel="stylesheet"></head><body class="blog"><div class="container mb-5"><nav class="navbar navbar-expand-md"><a class="navbar-brand p-0" href="/" aria-label="hyperbola"><img class="float-left" title="hyperbola" alt="Hyperbola logo" src="/ea3a0c4f0b6d4c1600f0444f02ac44d9.svg"/> <span class="sr-only">hyperbola</span> </a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto"><div class="container d-flex flex-column flex-md-row justify-content-end"><li class="nav-item"><a class="nav-link nav-link-frontpage" href="/">home</a></li><li class="nav-item"><a class="nav-link nav-link-contact" href="/contact/">contact</a></li><li class="nav-item"><a class="nav-link nav-link-lifestream" href="/lifestream/">lifestream</a></li><li class="nav-item"><a class="nav-link nav-link-blog" href="/w/">blog</a></li></div></ul></div></nav><div class="card hyperbola-section-title my-3 w-100"><div class="card-body"><span class="card-title"><strong>hyperbo.la :: Source-level Polymorphism in Rust</strong></span></div></div><div class="row"><div class="col-lg-9 mx-auto"><div class="card mb-3"><div class="card-body"><h2 class="card-title text-center"><a href="/w/source-level-polymorphism/">Source-level Polymorphism in Rust</a></h2><div class="h6 card-subtitle text-center mb-2 hyperbola-text-timestamp"><a href="/contact/">Ryan Lopopolo</a> | December 24, 2020</div><div class="card-text"><p><a href="https://www.artichokeruby.org/">Artichoke Ruby</a> is a Ruby <a href="https://github.com/artichoke/artichoke">implemented in Rust</a>. As Artichoke <a href="https://martinfowler.com/bliki/StranglerFigApplication.html">strangles</a> its <a href="https://github.com/mruby/mruby">mruby</a> core, I&#39;ve been capturing core data structures from the VM into Rust code.</p><p>Artichoke is a Cargo workspace and uses separate crates for implementing the data structures that back Ruby Core APIs.</p><p>Splitting core data structures into their own crates helps me ensure they are high quality. For example, crates <a href="https://github.com/artichoke/artichoke/blob/cc1d0764d2e3252b917608b6a46bf198a90fd9a1/spinoso-array/src/lib.rs#L9-L10">fail CI if they have missing documentation</a>. Using a separate crate for each data structure also makes it easier to have multiple implementations of the API.</p><h3 id="multiple-implementations">Multiple Implementations</h3><p>Having multiple implementations of core data structures allows Artichoke to be built with different use cases in mind. For example, Artichoke distributes a <code>ruby</code> CLI frontend that should allow users to interact with the host system; but Artichoke also aims to support embedding use cases which may wish to limit the ways the interpreter may interact with the host system. <code>VISION.md</code> expounds on <a href="https://github.com/artichoke/artichoke/blob/cc1d0764d2e3252b917608b6a46bf198a90fd9a1/VISION.md">Artichoke&#39;s design and goals</a>.</p><h4 id="array">Array</h4><p><a href="https://artichoke.github.io/artichoke/spinoso_array/index.html"><code>spinoso-array</code></a> is the crate that implements the contiguous buffer type that backs <a href="https://ruby-doc.org/core-2.6.3/Array.html">Ruby <code>Array</code></a>. Using conditional compilation with <a href="https://doc.rust-lang.org/cargo/reference/features.html">cargo features</a>, <code>spinoso-array</code> by default exposes two concrete buffer types: <a href="https://artichoke.github.io/artichoke/spinoso_array/struct.Array.html"><code>Array</code></a>, which is backed by a Rust <a href="https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html"><code>Vec</code></a>, and <a href="https://artichoke.github.io/artichoke/spinoso_array/struct.SmallArray.html"><code>SmallArray</code></a>, which is backed by a <a href="https://docs.rs/smallvec/1.5.1/smallvec/struct.SmallVec.html"><code>SmallVec</code></a>.</p><p><code>spinoso-array</code> does not have a trait that unifies these two types to ensure they can be used interchangeably. Instead, these structs implement the exact same API. Flipping between implementations is as simple as changing an import:</p><pre><code class="hljs language-rust"><span class="hljs"><span class="hljs-keyword">use</span> spinoso_array::Array <span class="hljs-keyword">as</span> SpinosoArray;
<span class="hljs-comment">// or</span>
<span class="hljs-keyword">use</span> spinoso_array::SmallArray <span class="hljs-keyword">as</span> SpinosoArray;</span></code></pre><h4 id="env">ENV</h4><p>Another data structure that implements the multiple backend pattern is Artichoke&#39;s access to environment variables. <a href="https://artichoke.github.io/artichoke/spinoso_env/index.html"><code>spinoso-env</code></a> implements multiple types that expose an identical API for accessing the environment:</p><ul><li><a href="https://artichoke.github.io/artichoke/spinoso_env/struct.System.html"><code>System</code></a> is a wrapper around <a href="https://doc.rust-lang.org/stable/std/env/index.html"><code>std::env</code></a> and gives Ruby code access to the platform environment variables via native APIs.</li><li><a href="https://artichoke.github.io/artichoke/spinoso_env/struct.Memory.html"><code>Memory</code></a> is a wrapper around a <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code>HashMap</code></a>, which allows Ruby code to have a functional <a href="https://ruby-doc.org/core-2.6.3/ENV.html"><code>ENV</code></a> in environments where mutable access to the host system&#39;s environment is undesirable (if embedding Artichoke in another application) or unavailable (if building for e.g. the <code>wasm32-unknown-unknown</code> target).</li></ul><p>The Artichoke VM is <a href="https://github.com/artichoke/artichoke/blob/cc1d0764d2e3252b917608b6a46bf198a90fd9a1/Cargo.toml#L86-L90">configurable at compile-time</a> to select the <code>ENV</code> backend:</p><pre><code class="hljs language-toml"><span class="hljs"><span class="hljs-section">[features]</span>
<span class="hljs-comment"># Enable resolving environment variables with the `ENV` core object.</span>
<span class="hljs-attr">core-env</span> = [<span class="hljs-string">&quot;spinoso-env&quot;</span>]
<span class="hljs-comment"># Enable resolving environment variables with the `ENV` core object using native</span>
<span class="hljs-comment"># OS APIs. This feature replaces the in-memory backend with `std::env`.</span>
<span class="hljs-attr">core-env-system</span> = [<span class="hljs-string">&quot;core-env&quot;</span>, <span class="hljs-string">&quot;spinoso-env/system-env&quot;</span>]</span></code></pre><p>The code that wires up the environment backend indirects the concrete type with a <a href="https://github.com/artichoke/artichoke/blob/cc1d0764d2e3252b917608b6a46bf198a90fd9a1/artichoke-backend/src/extn/core/env/mod.rs#L30-L33">conditionally-compiled type alias</a> and requires no other code changes:</p><pre><code class="hljs language-rust"><span class="hljs"><span class="hljs-meta">#[cfg(not(feature = <span class="hljs-meta-string">&quot;core-env-system&quot;</span>))]</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Backend</span></span> = spinoso_env::Memory;
<span class="hljs-meta">#[cfg(feature = <span class="hljs-meta-string">&quot;core-env-system&quot;</span>)]</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Backend</span></span> = spinoso_env::System;</span></code></pre><h3 id="polymorphism">Polymorphism</h3><p>Source-compatible data structure implementations have the following nice properties:</p><ul><li>Traits don&#39;t need to be in scope to use data structure APIs.</li><li>No reliance on trait objects.</li><li>No monomorphization or generics.</li><li>Conditional compilation is lightweight.</li></ul></div></div></div></div></div></div><script src="/main.c9c77d89967e1d70dbdc.js"></script></body></html>